// Define a breakpoints module
var breakpoints = (function() {
    "use strict";

    // Initialize the module with a list of breakpoints
    function initBreakpoints(config) {
        internal.init(config);
    }

    // Internal object to manage breakpoints and events
    var internal = {
        list: null,
        media: {},
        events: [],

        // Initialize by setting the list and adding event listeners
        init: function(config) {
            this.list = config;
            window.addEventListener("resize", this.poll);
            window.addEventListener("orientationchange", this.poll);
            window.addEventListener("load", this.poll);
            window.addEventListener("fullscreenchange", this.poll);
        },

        // Check if a breakpoint is active
        active: function(query) {
            var mode, breakpointName, min, max, unit;

            if (!(query in this.media)) {
                // Determine mode and breakpoint name
                if (query.startsWith(">=")) {
                    mode = "gte";
                    breakpointName = query.slice(2);
                } else if (query.startsWith("<=")) {
                    mode = "lte";
                    breakpointName = query.slice(2);
                } else if (query.startsWith(">")) {
                    mode = "gt";
                    breakpointName = query.slice(1);
                } else if (query.startsWith("<")) {
                    mode = "lt";
                    breakpointName = query.slice(1);
                } else if (query.startsWith("!")) {
                    mode = "not";
                    breakpointName = query.slice(1);
                } else {
                    mode = "eq";
                    breakpointName = query;
                }

                // Check if the breakpoint exists in the list
                if (breakpointName && breakpointName in this.list) {
                    var range = this.list[breakpointName];

                    if (Array.isArray(range)) {
                        min = parseInt(range[0]);
                        max = parseInt(range[1]);
                        unit = isNaN(min) ? range[1].slice(String(max).length) : range[0].slice(String(min).length);
                    }

                    // Build media query string based on mode
                    switch (mode) {
                        case "gte":
                            this.media[query] = `screen and (min-width: ${min}${unit})`;
                            break;
                        case "lte":
                            this.media[query] = `screen and (max-width: ${max}${unit})`;
                            break;
                        case "gt":
                            this.media[query] = `screen and (min-width: ${min + 1}${unit})`;
                            break;
                        case "lt":
                            this.media[query] = `screen and (max-width: ${min - 1}${unit})`;
                            break;
                        case "not":
                            this.media[query] = `screen and (max-width: ${min - 1}${unit}), screen and (min-width: ${max + 1}${unit})`;
                            break;
                        default:
                            this.media[query] = `screen and (min-width: ${min}${unit}) and (max-width: ${max}${unit})`;
                    }
                }
            }

            // Return the result of the media query
            return this.media[query] ? window.matchMedia(this.media[query]).matches : false;
        },

        // Register an event handler for a breakpoint
        on: function(query, handler) {
            this.events.push({ query: query, handler: handler, state: false });
            if (this.active(query)) {
                handler();
            }
        },

        // Poll all registered events and trigger handlers accordingly
        poll: function() {
            for (var i = 0; i < this.events.length; i++) {
                var event = this.events[i];
                if (this.active(event.query)) {
                    if (!event.state) {
                        event.state = true;
                        event.handler();
                    }
                } else {
                    event.state = false;
                }
            }
        }
    };

    // Expose public methods
    initBreakpoints._ = internal;
    initBreakpoints.on = function(query, handler) {
        internal.on(query, handler);
    };
    initBreakpoints.active = function(query) {
        return internal.active(query);
    };

    return initBreakpoints;
})();

// Export the module for various environments
(function(global, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        global.breakpoints = factory();
    }
})(this, function() {
    return breakpoints;
});
