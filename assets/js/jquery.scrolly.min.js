var browser = (function() {
    "use strict";

    var browserInfo = {
        name: null,
        version: null,
        os: null,
        osVersion: null,
        touch: null,
        mobile: null,
        _canUse: null,

        // Method to check if a CSS property can be used
        canUse: function(property) {
            if (!this._canUse) {
                this._canUse = document.createElement("div");
            }
            var style = this._canUse.style;
            var capitalized = property.charAt(0).toUpperCase() + property.slice(1);
            return property in style || "Moz" + capitalized in style || "Webkit" + capitalized in style || "O" + capitalized in style || "ms" + capitalized in style;
        },

        // Initialize the browser detection
        init: function() {
            var userAgent = navigator.userAgent;
            var detectedBrowser = "other", version = 0;
            var browsers = [
                ["firefox", /Firefox\/([0-9\.]+)/],
                ["bb", /BlackBerry.+Version\/([0-9\.]+)/],
                ["bb", /BB[0-9]+.+Version\/([0-9\.]+)/],
                ["opera", /OPR\/([0-9\.]+)/],
                ["opera", /Opera\/([0-9\.]+)/],
                ["edge", /Edge\/([0-9\.]+)/],
                ["safari", /Version\/([0-9\.]+).+Safari/],
                ["chrome", /Chrome\/([0-9\.]+)/],
                ["ie", /MSIE ([0-9]+)/],
                ["ie", /Trident\/.+rv:([0-9]+)/]
            ];

            for (var i = 0; i < browsers.length; i++) {
                if (userAgent.match(browsers[i][1])) {
                    detectedBrowser = browsers[i][0];
                    version = parseFloat(RegExp.$1);
                    break;
                }
            }

            this.name = detectedBrowser;
            this.version = version;

            var detectedOS = "other", osVersion = 0;
            var operatingSystems = [
                ["ios", /([0-9_]+) like Mac OS X/, function(v) { return v.replace("_", ".").replace("_", ""); }],
                ["ios", /CPU like Mac OS X/, function() { return 0; }],
                ["wp", /Windows Phone ([0-9\.]+)/, null],
                ["android", /Android ([0-9\.]+)/, null],
                ["mac", /Macintosh.+Mac OS X ([0-9_]+)/, function(v) { return v.replace("_", ".").replace("_", ""); }],
                ["windows", /Windows NT ([0-9\.]+)/, null],
                ["bb", /BlackBerry.+Version\/([0-9\.]+)/, null],
                ["bb", /BB[0-9]+.+Version\/([0-9\.]+)/, null],
                ["linux", /Linux/, null],
                ["bsd", /BSD/, null],
                ["unix", /X11/, null]
            ];

            for (var j = 0; j < operatingSystems.length; j++) {
                if (userAgent.match(operatingSystems[j][1])) {
                    detectedOS = operatingSystems[j][0];
                    osVersion = parseFloat(operatingSystems[j][2] ? operatingSystems[j][2](RegExp.$1) : RegExp.$1);
                    break;
                }
            }

            if (detectedOS === "mac" && "ontouchstart" in window &&
                ([1024, 834, 810, 768].includes(screen.width) && [1366, 1112, 1080, 1024].includes(screen.height))) {
                detectedOS = "ios";
            }

            this.os = detectedOS;
            this.osVersion = osVersion;
            this.touch = (detectedOS === "wp") ? navigator.msMaxTouchPoints > 0 : ("ontouchstart" in window);
            this.mobile = ["wp", "android", "ios", "bb"].includes(detectedOS);
        }
    };

    // Initialize browser information
    browserInfo.init();

    return browserInfo;
})();

// Export the module for various environments
(function(global, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        global.browser = factory();
    }
})(this, function() {
    return browser;
});

// Define a scroll event handling module
(function($) {
    function parseValue(value, viewportHeight, windowHeight) {
        if (typeof value === "string") {
            if (value.endsWith("%")) {
                return parseInt(value.slice(0, -1)) / 100 * viewportHeight;
            } else if (value.endsWith("vh")) {
                return parseInt(value.slice(0, -2)) / 100 * windowHeight;
            } else if (value.endsWith("px")) {
                return parseInt(value.slice(0, -2));
            }
        }
        return value;
    }

    var $window = $(window),
        scrollexIdCounter = 1,
        handlers = {};

    $window.on("scroll", function() {
        var scrollTop = $window.scrollTop();
        $.map(handlers, function(handler) {
            clearTimeout(handler.timeoutId);
            handler.timeoutId = setTimeout(function() {
                handler.callback(scrollTop);
            }, handler.options.delay);
        });
    }).on("load", function() {
        $window.trigger("scroll");
    });

    $.fn.scrollex = function(options) {
        var $this = $(this);
        if (this.length === 0) return $this;
        if (this.length > 1) {
            this.each(function() {
                $(this).scrollex(options);
            });
            return $this;
        }

        if ($this.data("_scrollexId")) return $this;

        var id = scrollexIdCounter++,
            settings = $.extend({
                top: 0,
                bottom: 0,
                delay: 0,
                mode: "default",
                enter: null,
                leave: null,
                initialize: null,
                terminate: null,
                scroll: null
            }, options),
            testFunction;

        switch (settings.mode) {
            case "top":
                testFunction = function(t, m, b, r, a) { return t >= r && a >= t; };
                break;
            case "bottom":
                testFunction = function(t, m, b, r, a) { return b >= r && a >= b; };
                break;
            case "middle":
                testFunction = function(t, m, b, r, a) { return m >= r && a >= m; };
                break;
            case "top-only":
                testFunction = function(t, m, b, r, a) { return r >= t && b >= r; };
                break;
            case "bottom-only":
                testFunction = function(t, m, b, r, a) { return b >= a && a >= t; };
                break;
            default:
                testFunction = function(t, m, b, r, a) { return b >= r && a >= t; };
                break;
        }

        var handler = {
            id: id,
            options: settings,
            test: testFunction,
            callback: function(scrollTop) {
                var viewportHeight = $window.height(),
                    middle = scrollTop + viewportHeight / 2,
                    bottom = scrollTop + viewportHeight,
                    elementHeight = $this.outerHeight(),
                    offsetTop = $this.offset().top,
                    rangeTop = offsetTop + parseValue(settings.top, elementHeight, viewportHeight),
                    rangeBottom = offsetTop + elementHeight - parseValue(settings.bottom, elementHeight, viewportHeight),
                    state = handler.test(scrollTop, middle, bottom, rangeTop, rangeBottom);

                if (state !== handler.state) {
                    handler.state = state;
                    if (state) {
                        settings.enter && settings.enter.apply($this[0]);
                    } else {
                        settings.leave && settings.leave.apply($this[0]);
                    }
                }

                settings.scroll && settings.scroll.apply($this[0], [(middle - rangeTop) / (rangeBottom - rangeTop)]);
            },
            state: null,
            $element: $this,
            timeoutId: null
        };

        handlers[id] = handler;
        $this.data("_scrollexId", id);

        settings.initialize && settings.initialize.apply(this);
        return $this;
    };

    $.fn.unscrollex = function() {
        var $this = $(this);
        if (this.length === 0) return $this;
        if (this.length > 1) {
            this.each(function() {
                $(this).unscrollex();
            });
            return $this;
        }

        var id = $this.data("_scrollexId"),
            handler = handlers[id];

        if (id) {
            clearTimeout(handler.timeoutId);
            delete handlers[id];
            $this.removeData("_scrollexId");
            handler.options.terminate && handler.options.terminate.apply(this);
        }

        return $this;
    };
})(jQuery);

// Define a scrolly event handling module
(function($) {
    function getScrollTargetOffset(target, options) {
        var $target = $(target);
        if ($target.length === 0) return null;

        var targetOffsetTop = $target.offset().top,
            offset = typeof options.offset === "function" ? options.offset() : options.offset;

        switch (options.anchor) {
            case "middle":
                return targetOffsetTop - ($(window).height() - $target.outerHeight()) / 2 - offset;
            default:
                return Math.max(targetOffsetTop - offset, 0);
        }
    }

    $.fn.scrolly = function(options) {
        var $this = $(this);
        if (this.length === 0) return $this;
        if (this.length > 1) {
            this.each(function() {
                $(this).scrolly(options);
            });
            return $this;
        }

        var settings = $.extend({
            anchor: "top",
            easing: "swing",
            offset: 0,
            parent: $("body,html"),
            pollOnce: false,
            speed: 1000
        }, options);

        var cachedScrollTargetOffset = settings.pollOnce ? getScrollTargetOffset($this.attr("href"), settings) : null;

        $this.off("click.scrolly").on("click.scrolly", function(event) {
            var scrollTargetOffset = cachedScrollTargetOffset !== null ? cachedScrollTargetOffset : getScrollTargetOffset($this.attr("href"), settings);
            if (scrollTargetOffset !== null) {
                event.preventDefault();
                settings.parent.stop().animate({ scrollTop: scrollTargetOffset }, settings.speed, settings.easing);
            }
        });

        return $this;
    };
})(jQuery);